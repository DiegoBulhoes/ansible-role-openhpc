---
- name: Select slurm service to control # TODO: handle multiple (don't think existing role doesn't) and none?
  set_fact:
    openhpc_slurm_service: "{{ openhpc_slurm_services[item] }}"
  loop: "{{ openhpc_slurm_services.keys() | list }}"
  when: "openhpc_enable[item]"
# alternative non-loop implementation:
# openhpc_slurm_service: "{{ openhpc_enable | dict2items | selectattr('value') | map(attribute='key') | list | intersect(openhpc_slurm_services.keys()) | first }}"
# python equivalent: set([openhpc_slurm_services[k] for (k, v) in openhpc_enable.items() if v]).intersect(openhpc_slurm_services.keys())[0]

# NB: below approach means user cannot choose order of actions, but we can control delegate to/run once etc
- include_tasks: "install.yml"
  when:
    - "'install' in query('items', openhpc_actions)" # ensures a list even if passed a single item
  
- include_tasks: "configure.yml"
  when:
    - "'configure' in query('items', openhpc_actions)"
    - openhpc_enable.runtime | default(false) | bool # TODO: clear up what `runtime` is supposed to be and ditch this

- include_tasks: "start.yml"
  when:
    - "'start' in query('items', openhpc_actions)"
    - openhpc_enable.runtime | default(false) | bool # TODO: clear up what `runtime` is supposed to be and ditch this

- include: drain.yml
  when: openhpc_enable.drain | default(false) | bool
  delegate_to: "{{ openhpc_slurm_control_host }}"

- include: resume.yml
  when: openhpc_enable.resume | default(false) | bool
  delegate_to: "{{ openhpc_slurm_control_host }}"

- include_tasks: "hard_reconfigure.yml"
  when: "'hard_reconfigure' in query('items', openhpc_actions)"

- include_tasks: "soft_reconfigure.yml"
  when: "'soft_reconfigure' in query('items', openhpc_actions)"

...
